Docs
https://www.cppreference.com/Cpp_STL_ReferenceManual.pdf

**adaptador de container

we basically override the stack by referring to its underlying container
using type alias to sideline its lack of iterator 

### O que √© typedef em C++?

O typedef em C++ √© usado para criar aliases (apelidos) para tipos de dados. Isso pode tornar o c√≥digo mais leg√≠vel e f√°cil de modificar. A partir do C++11, o typedef pode ser substitu√≠do por using, que √© uma forma mais moderna e leg√≠vel.
Exemplo b√°sico de typedef:

typedef unsigned int uint;
uint idade = 25; // Agora uint √© um alias para unsigned int

Aqui, uint √© apenas um novo nome para unsigned int, facilitando a escrita e leitura do c√≥digo.


---

typedef typename std::stack<T>::container_type under_ctr;

std::stack<T> √© uma pilha baseada em um container subjacente (por padr√£o, std::deque<T>).
O container_type √© um tipo interno da std::stack<T>, que representa o container usado para armazenar os elementos.
Esse typedef cria um alias chamado under_ctr para esse tipo.

---

### **`typedef typename` √© sempre obrigat√≥rio?**
Depende da situa√ß√£o! Vamos entender quando **precisamos** usar `typename` junto com `typedef` e quando podemos usar apenas `typedef`.

---

## **1. Quando usar apenas `typedef`?**
Se estivermos criando um alias para um **tipo comum** que n√£o depende de um par√¢metro de template, podemos simplesmente usar `typedef`.

‚úÖ **Exemplo sem templates (n√£o precisa de `typename`)**
```cpp
typedef unsigned int uint; // Apenas um alias normal
typedef std::deque<int> IntDeque; // Criando um alias para std::deque<int>
```
Neste caso, `typedef` funciona sozinho porque `unsigned int` e `std::deque<int>` j√° s√£o **tipos concretos conhecidos pelo compilador**.

---

## **2. Quando usar `typedef typename`?**
Se estivermos criando um alias dentro de **uma classe template**, onde o tipo ainda **n√£o √© completamente conhecido** pelo compilador, precisamos usar `typename` junto com `typedef`.

### **Por qu√™?**
O compilador C++ n√£o sabe antecipadamente se algo dentro de um tipo de template √© um **tipo (type)** ou um **atributo (member)**. Ent√£o, usamos `typename` para dizer explicitamente ao compilador que aquilo √© um **tipo**.

---

‚úÖ **Exemplo onde `typename` √© necess√°rio**
```cpp
template <typename T>
class MyClass {
public:
    typedef typename std::vector<T>::iterator Iterator;
};
```
**Explica√ß√£o**:
- `std::vector<T>::iterator` √© um **tipo dependente de template** (`T` ainda n√£o √© conhecido).
- O compilador pode se confundir e achar que `iterator` √© um atributo (vari√°vel) em vez de um tipo.
- Ent√£o, **precisamos** de `typename` para indicar que `iterator` √© um **tipo**.

---

## **3. O caso do `MutantStack`**
No seu c√≥digo, temos:

```cpp
typedef typename std::stack<T>::container_type under_ctr;
typedef typename under_ctr::iterator iterator;
typedef typename under_ctr::const_iterator const_iterator;
```
- `std::stack<T>::container_type` √© **um tipo dependente de template**, ent√£o **precisamos** de `typename`.
- `under_ctr::iterator` e `under_ctr::const_iterator` **tamb√©m s√£o tipos dependentes**, ent√£o **precisamos** de `typename`.

Se **remov√™ssemos `typename`**, o compilador daria erro, porque ele n√£o teria certeza de que `container_type` e `iterator` s√£o **tipos**.

---

## **Conclus√£o**
- ‚úÖ Se for um **tipo normal e conhecido** ‚Üí **Use apenas `typedef`**.
- ‚úÖ Se for um **tipo dependente de template** ‚Üí **Use `typedef typename`**.

üöÄ **Regra pr√°tica:** Sempre que estiver dentro de um **template** e for referenciar um **tipo que depende de `T`**, use `typename` para evitar erros do compilador!


### **O que √© um container subjacente?**
Em C++, um **container subjacente** (**underlying container**) √© o container interno utilizado por certos adaptadores de containers da STL (**Standard Template Library**) para armazenar seus elementos.  
Isso ocorre porque alguns containers n√£o gerenciam diretamente os elementos, mas utilizam outro container internamente para isso.

---

## **Exemplo: `std::stack<T>` e seu container subjacente**
O `std::stack<T>` √© um adaptador de container. Isso significa que ele **n√£o armazena os elementos diretamente**, mas usa outro container (como `std::deque<T>` por padr√£o) para armazen√°-los.

### **Como o `std::stack<T>` funciona internamente?**
Por padr√£o, o `std::stack<T>` usa um `std::deque<T>` como seu **container subjacente**.

```cpp
std::stack<int> s;  // Internamente, isso usa std::deque<int> por padr√£o
```

Podemos mudar o container subjacente para outro compat√≠vel, como `std::vector<T>` ou `std::list<T>`:

```cpp
std::stack<int, std::vector<int>> s; // Agora o stack usa um vector internamente
std::stack<int, std::list<int>> s;   // Agora o stack usa uma list internamente
```

Esse container subjacente √© acess√≠vel pelo tipo `container_type`, como veremos a seguir.

---

## **Acessando o container subjacente**
Embora o `std::stack<T>` **n√£o forne√ßa iteradores**, o container subjacente sim. Podemos acess√°-lo usando `container_type`:

```cpp
#include <iostream>
#include <stack>
#include <vector>

int main() {
    std::stack<int, std::vector<int>> s; // Usando um vector como container interno

    s.push(1);
    s.push(2);
    s.push(3);

    // Acessando o container subjacente
    std::vector<int> &vec = s.*c;  // N√ÉO FUNCIONA! `c` √© protegido.

    return 0;
}
```

A vari√°vel `c` que cont√©m o container subjacente √© **protegida (`protected`)**, ent√£o n√£o podemos acess√°-la diretamente. Mas podemos **criar um wrapper para expor esse comportamento**, como na `MutantStack`:

---

## **Usando o container subjacente na `MutantStack`**
Na sua `MutantStack`, estamos acessando diretamente o container subjacente para permitir **itera√ß√µes**.

```cpp
typedef typename std::stack<T>::container_type under_ctr;
```
Aqui, `under_ctr` √© um **alias para o container subjacente** (`std::deque<T>` por padr√£o).

Depois, criamos iteradores baseados nesse container:
```cpp
typedef typename under_ctr::iterator iterator;
typedef typename under_ctr::const_iterator const_iterator;
```

E finalmente, implementamos os m√©todos `begin()` e `end()` para expor esses iteradores:

```cpp
iterator begin() { return this->c.begin(); }
iterator end() { return this->c.end(); }
```

Agora, conseguimos iterar sobre a pilha (`MutantStack`), algo que **n√£o √© poss√≠vel com um `std::stack<T>` normal**.

---

## **Resumo**
- O **container subjacente** √© o container interno usado por adaptadores de container, como `std::stack<T>`.
- Por padr√£o, `std::stack<T>` usa `std::deque<T>` como container subjacente, mas podemos mudar para `std::vector<T>` ou `std::list<T>`.
- O container subjacente pode ser acessado pelo tipo `container_type`, mas sua vari√°vel interna `c` √© protegida (`protected`).
- A `MutantStack` usa o container subjacente para adicionar iteradores, permitindo percorrer seus elementos.

Agora sua `MutantStack` funciona como uma pilha, mas tamb√©m permite itera√ß√£o como um `std::deque<T>`! üöÄ

### Membro protegido chamado C ###

No c√≥digo fornecido, o `c` representa o **container subjacente** da classe `MutantStack`. Esse √© um membro protegido da classe `std::stack` da biblioteca padr√£o do C++.  

### Explica√ß√£o:  

A classe `std::stack` em C++ √© um cont√™iner adaptador, o que significa que ela √© constru√≠da sobre outro cont√™iner (como `std::deque`, `std::vector` ou `std::list`). Esse cont√™iner interno pode ser acessado atrav√©s do membro protegido chamado **`c`**.  

No trecho do c√≥digo:  

```cpp
template<typename T>
typename MutantStack<T>::iterator MutantStack<T>::begin()
{
	return (this->c.begin());
}
```
- `this->c` acessa o cont√™iner subjacente da `std::stack`.
- `.begin()` retorna um iterador apontando para o primeiro elemento desse cont√™iner.

### Observa√ß√£o Importante  

A classe `std::stack` **n√£o fornece iteradores por padr√£o** porque √© uma estrutura baseada no conceito de **Pilha (LIFO)**. No entanto, ao expor o iterador do container subjacente (`c`), a `MutantStack` permite a itera√ß√£o sobre seus elementos, algo que n√£o √© poss√≠vel diretamente com `std::stack`.

Se precisar de mais detalhes, posso explicar com um c√≥digo completo! üöÄ

---

### **Como saber se uma estrutura usa um container subjacente?**  
Uma **estrutura utiliza um container subjacente** quando √© um **adaptador de container** (**container adapter**).  

üìå **O que √© um adaptador de container?**  
- Um adaptador de container **n√£o armazena elementos diretamente**, mas usa outro container internamente para fazer isso.  
- Ele apenas **restringe ou modifica** a interface desse container interno, fornecendo uma funcionalidade espec√≠fica.  
- Exemplos: `std::stack<T>`, `std::queue<T>`, `std::priority_queue<T>`  

---

## **üîç Como descobrir se uma estrutura usa um container subjacente?**  

### **1Ô∏è‚É£ Pela documenta√ß√£o da STL**  
A documenta√ß√£o oficial do C++ geralmente menciona que a estrutura √© um **adaptador de container** e usa um **container subjacente padr√£o**.  

Exemplo da documenta√ß√£o do `std::stack<T>`:
> "std::stack is a container adaptor that gives the programmer the functionality of a stack ‚Äî specifically, a LIFO (last-in, first-out) data structure. The class template acts as a wrapper to the underlying container."

üîé A palavra **"container adaptor"** j√° indica que `std::stack<T>` usa um container interno.

---

### **2Ô∏è‚É£ Pela defini√ß√£o da estrutura na STL**  
Se olharmos a defini√ß√£o de `std::stack<T>` no c√≥digo-fonte da STL, veremos que ele usa um **template** para o container subjacente:

```cpp
template <typename T, typename Container = std::deque<T>>
class stack {
protected:
    Container c;  // O container subjacente que realmente armazena os elementos
public:
    void push(const T& val) { c.push_back(val); }
    void pop() { c.pop_back(); }
    T& top() { return c.back(); }
};
```
üîç O `std::stack<T>` **n√£o implementa diretamente o armazenamento de elementos**. Ele **depende de um container interno** (`c`) para isso.

---

### **3Ô∏è‚É£ Pela aus√™ncia de iteradores (`begin()`, `end()`)**  
Adaptadores de container geralmente **n√£o fornecem iteradores** porque **n√£o exp√µem diretamente seus elementos internos**.  

Exemplo:
```cpp
std::stack<int> s;
s.push(1);
s.push(2);

// ‚ùå ERRO! std::stack<T> n√£o tem iteradores:
for (std::stack<int>::iterator it = s.begin(); it != s.end(); ++it) {
    std::cout << *it;
}
```
‚ùå O c√≥digo acima **n√£o compila**, pois `std::stack<T>` **n√£o fornece iteradores**!  
Isso ocorre porque ele **esconde o container interno** e s√≥ permite acesso controlado via `push()`, `pop()` e `top()`.

üìå **Conclus√£o**: Se uma estrutura da STL **n√£o fornece iteradores**, pode ser um adaptador de container.

---

## **üìå Estruturas que utilizam container subjacente**  
As principais estruturas da STL que utilizam **containers subjacentes** s√£o:

| Estrutura | Tipo de Adapta√ß√£o | Container Padr√£o |
|-----------|-----------------|----------------|
| `std::stack<T>` | **Pilha (LIFO)** | `std::deque<T>` |
| `std::queue<T>` | **Fila (FIFO)** | `std::deque<T>` |
| `std::priority_queue<T>` | **Fila de prioridade (heap m√°ximo)** | `std::vector<T>` |

### **üîπ `std::queue<T>` (Fila FIFO)**
```cpp
std::queue<int> q;  // Internamente usa std::deque<int>
```
- Usa `std::deque<T>` por padr√£o.
- **Permite acesso apenas ao in√≠cio e ao fim**.
- **N√£o tem iteradores**.

---

### **üîπ `std::priority_queue<T>` (Fila de prioridade)**
```cpp
std::priority_queue<int> pq;  // Internamente usa std::vector<int>
```
- Usa `std::vector<T>` por padr√£o.
- **Ordena os elementos internamente** com um heap.
- **N√£o tem iteradores**.

---

## **üõ† Como acessar o container subjacente?**  
Por padr√£o, o container interno (`c`) de `std::stack<T>`, `std::queue<T>` e `std::priority_queue<T>` √© **protegido** (`protected`).  
Mas podemos acessar ele em uma classe derivada:

```cpp
#include <iostream>
#include <stack>

template <typename T>
class MyStack : public std::stack<T> {
public:
    void print() {
        typename std::stack<T>::container_type& container = this->c;
        for (auto it = container.begin(); it != container.end(); ++it) {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MyStack<int> s;
    s.push(1);
    s.push(2);
    s.push(3);
    
    s.print();  // Sa√≠da: 1 2 3
}
```
üëâ **Aqui, conseguimos acessar `c` e iterar sobre o container subjacente!** üöÄ

---

## **üìå Resumo**
- **Containers adaptadores** (como `std::stack<T>`, `std::queue<T>`, `std::priority_queue<T>`) **usam um container subjacente** para armazenar elementos.  
- **O container subjacente padr√£o varia** (`std::deque<T>` para `std::stack<T>` e `std::queue<T>`, `std::vector<T>` para `std::priority_queue<T>`).  
- **Eles n√£o possuem iteradores (`begin()`, `end()`)**, pois escondem o container interno.  
- **Podemos acessar o container subjacente (`c`) em uma classe derivada**.

Isso explica **como identificar e manipular containers subjacentes**! üöÄ